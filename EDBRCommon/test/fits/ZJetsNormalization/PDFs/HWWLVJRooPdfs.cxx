/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was generated by  Zijun Xu                           * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

//#include "../interface/HWWLVJ_RooPdfs.h"
#include "HWWLVJRooPdfs.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include "RooExponential.h" 
#include <math.h> 
#include "TMath.h" 

#include <algorithm>
#include <vector>
#include <string>

#include "RooPlot.h"
#include "TFile.h"
#include "TTree.h"
#include "TH1F.h"
#include "TChain.h"
#include "TString.h"
#include "TRandom3.h"
#include "TCanvas.h"
#include "TIterator.h"
#include "RooHist.h"
#include "RooRealVar.h"
#include "RooFitResult.h"
#include "RooWorkspace.h"
#include "RooCurve.h"
#include "RooAbsPdf.h"
#include "RooAbsData.h"
#include "RooDataSet.h"
#include "RooDataHist.h"
#include "RooRealProxy.h"
#include "RooAbsReal.h"
#include "RooExtendPdf.h"
#include "RooRealVar.h"
#include "RooDataSet.h"
#include "RooDataHist.h"
#include "RooGaussian.h"
#include "TCanvas.h"
#include "RooPlot.h"
#include "TTree.h"
#include "TH1D.h"
#include "TRandom.h"
#include "TGraph.h"
#include "TGraphAsymmErrors.h"
#include <iostream>
using namespace std;

Double_t ErfExp(Double_t x, Double_t c, Double_t offset, Double_t width){
    if(width<1e-2)width=1e-2;
    if (c==0)c=-1e-7;
	return TMath::Exp(c*x)*(1.+TMath::Erf((x-offset)/width))/2. ;
}

Double_t ErfExp(Double_t x, Double_t x_min, Double_t x_max, Double_t c, Double_t offset, Double_t width){
    if(width<1e-2)width=1e-2;
    if (c==0)c=1e-7;
    double minTerm = (TMath::Exp(c*c*width*width/4+c*offset) * 
					TMath::Erf((2*x_min-c*width*width-
							2*offset)/2/width) - 
					TMath::Exp(c*x_min) * 
					TMath::Erf((x_min-offset)/width) - 
					TMath::Exp(c*x_min))/-2/c;
	double maxTerm = (TMath::Exp(c*c*width*width/4+c*offset) * 
					TMath::Erf((2*x_max-c*width*width-
							2*offset)/2/width) - 
					TMath::Exp(c*x_max) * 
					TMath::Erf((x_max-offset)/width) - 
					TMath::Exp(c*x_max))/-2/c;
	Double_t integral=(maxTerm-minTerm) ;
	return TMath::Exp(c*x)*(1.+TMath::Erf((x-offset)/width))/2./integral ;
}


Double_t Exp(Double_t x, Double_t c){
	return TMath::Exp(c*x);
}

Double_t Exp(Double_t x, Double_t x_min, Double_t x_max, Double_t c){
	Double_t integral ;
    if(c==0.){
        integral=x_max-x_min;
    }else{
        integral= ( TMath::Exp(c*x_max)-TMath::Exp(c*x_min) ) / c;
    }
	return TMath::Exp(c*x)/integral ;
}

ClassImp(RooErfExpPdf) 

RooErfExpPdf::RooErfExpPdf(const char *name, const char *title, 
					RooAbsReal& _x,
					RooAbsReal& _c,
					RooAbsReal& _offset,
					RooAbsReal& _width) :
			RooAbsPdf(name,title), 
			x("x","x",this,_x),
			c("c","c",this,_c),
			offset("offset","offset",this,_offset),
			width("width","width",this,_width)
{ 
} 


RooErfExpPdf::RooErfExpPdf(const RooErfExpPdf& other, const char* name) :  
	RooAbsPdf(other,name), 
	x("x",this,other.x),
	c("c",this,other.c),
	offset("offset",this,other.offset),
	width("width",this,other.width)
{ 
} 



Double_t RooErfExpPdf::evaluate() const 
{ 
	// ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
	// return TMath::Exp(c*x)*(1.+TMath::Erf((x-offset)/width))/2. ; 
    Double_t width_tmp=width; if(width<1e-2){ width_tmp=1e-2;}
	return ErfExp(x,c,offset,width_tmp) ; 
} 

Int_t RooErfExpPdf::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
{ 
	// LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
	// ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
	// THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
	// YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
	// EXPRESSION MULTIPLE TIMES

	if (matchArgs(allVars,analVars,x)) return 1 ; 
	return 0 ; 
} 

Double_t RooErfExpPdf::analyticalIntegral(Int_t code, const char* rangeName) const  
{ 
	// RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
	// THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
	// BOUNDARIES FOR EACH OBSERVABLE x

    Double_t width_tmp=width; if(width<1e-2){ width_tmp=1e-2;}
	if (code==1) { 
        Double_t minTerm=0;
        Double_t maxTerm=0;
        if(c==0){ 
            Double_t delta=-1e-7;
            minTerm = (TMath::Exp(delta*delta*width_tmp*width_tmp/4+delta*offset) * 
					TMath::Erf((2*x.min(rangeName)-delta*width_tmp*width_tmp-
							2*offset)/2/width_tmp) - 
					TMath::Exp(delta*x.min(rangeName)) * 
					TMath::Erf((x.min(rangeName)-offset)/width_tmp) - 
					TMath::Exp(delta*x.min(rangeName)))/-2/delta;
		    maxTerm = (TMath::Exp(delta*delta*width_tmp*width_tmp/4+delta*offset) * 
					TMath::Erf((2*x.max(rangeName)-delta*width_tmp*width_tmp-
							2*offset)/2/width_tmp) - 
					TMath::Exp(delta*x.max(rangeName)) * 
					TMath::Erf((x.max(rangeName)-offset)/width_tmp) - 
					TMath::Exp(delta*x.max(rangeName)))/-2/delta;
        
        }else{
            minTerm = (TMath::Exp(c*c*width_tmp*width_tmp/4+c*offset) * 
					TMath::Erf((2*x.min(rangeName)-c*width_tmp*width_tmp-
							2*offset)/2/width_tmp) - 
					TMath::Exp(c*x.min(rangeName)) * 
					TMath::Erf((x.min(rangeName)-offset)/width_tmp) - 
					TMath::Exp(c*x.min(rangeName)))/-2/c;
		    maxTerm = (TMath::Exp(c*c*width_tmp*width_tmp/4+c*offset) * 
					TMath::Erf((2*x.max(rangeName)-c*width_tmp*width_tmp-
							2*offset)/2/width_tmp) - 
					TMath::Exp(c*x.max(rangeName)) * 
					TMath::Erf((x.max(rangeName)-offset)/width_tmp) - 
					TMath::Exp(c*x.max(rangeName)))/-2/c;
        }
		return (maxTerm-minTerm) ;
	} 
	return 0 ; 
} 

ClassImp(RooAlpha)

RooAlpha::RooAlpha(){}

RooAlpha::RooAlpha(const char *name, const char *title,
		   RooAbsReal& _x,
		   RooAbsReal& _c,
		   RooAbsReal& _offset,
		   RooAbsReal& _width,
		   RooAbsReal& _ca,
		   RooAbsReal& _offseta,
		   RooAbsReal& _widtha,
           Double_t _xmin,
           Double_t _xmax
	     ) :
  RooAbsPdf(name,title),
  x("x","x",this,_x),
  c("c","c",this,_c),
  offset("offset","offset",this,_offset),
  width("width","width",this,_width),
  ca("ca","ca",this,_ca),
  offseta("offseta","offseta",this,_offseta),
  widtha("widtha","widtha",this,_widtha)
{
        xmin=_xmin;
        xmax=_xmax;
}

RooAlpha::RooAlpha(const RooAlpha& other, const char* name) :
  RooAbsPdf(other,name),
  x("x",this,other.x),
  c("c",this,other.c),
  offset("offset",this,other.offset),
  width("width",this,other.width),
  ca("ca",this,other.ca),
  offseta("offseta",this,other.offseta),
  widtha("widtha",this,other.widtha)
{
        xmin=other.xmin;
        xmax=other.xmax;
}

double RooAlpha::evaluate() const
{
    Double_t width_tmp=width; if(width<1e-2){ width_tmp=1e-2;}
    Double_t widtha_tmp=widtha; if(widtha<1e-2){ widtha_tmp=1e-2;}
  return ErfExp(x,xmin,xmax,c,offset,width_tmp)/ErfExp(x,xmin,xmax,ca,offseta,widtha_tmp);
}



ClassImp(RooAlpha)

RooAlphaExp::RooAlphaExp(){}

RooAlphaExp::RooAlphaExp(const char *name, const char *title,
		   RooAbsReal& _x,
		   RooAbsReal& _c,
		   RooAbsReal& _ca,
           Double_t _xmin,
           Double_t _xmax
	     ) :
  RooAbsPdf(name,title),
  x("x","x",this,_x),
  c("c","c",this,_c),
  ca("ca","ca",this,_ca)
{
        xmin=_xmin;
        xmax=_xmax;
}

RooAlphaExp::RooAlphaExp(const RooAlphaExp& other, const char* name) :
  RooAbsPdf(other,name),
  x("x",this,other.x),
  c("c",this,other.c),
  ca("ca",this,other.ca)
{
        xmin=other.xmin;
        xmax=other.xmax;
}

double RooAlphaExp::evaluate() const
{
  return Exp(x,xmin,xmax,c)/Exp(x,xmin,xmax,ca);
}


///////////////////////////////////////RooBWRunPdf.cxx
ClassImp(RooBWRunPdf) 

 RooBWRunPdf::RooBWRunPdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _mean,
                        RooAbsReal& _width) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   mean("mean","mean",this,_mean),
   width("width","width",this,_width)
 { 
 } 


 RooBWRunPdf::RooBWRunPdf(const RooBWRunPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   mean("mean",this,other.mean),
   width("width",this,other.width)
 { 
 } 



 Double_t RooBWRunPdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   return (x*x*width/mean) / ( (x*x-mean*mean)*(x*x-mean*mean) + (x*x*width/mean)*(x*x*width/mean) );
 } 

//////////////////////////////////RooErfPow2Pdf.cxx
ClassImp(RooErfPow2Pdf) 

Double_t  ErfPow2(Double_t x,Double_t c0,Double_t c1, Double_t offset, Double_t width){
        if(width<1e-2)width=1e-2;
   Double_t sqrt_s=2000.;
   return TMath::Power(x/sqrt_s ,-1*(c0+c1*TMath::Log(x/sqrt_s)) )*(1+ TMath::Erf((x-offset)/width)) /2. ; 
 }

 RooErfPow2Pdf::RooErfPow2Pdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _c0,
                        RooAbsReal& _c1,
                        RooAbsReal& _offset,
                        RooAbsReal& _width) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   c0("c0","c0",this,_c0),
   c1("c1","c1",this,_c1),
   offset("offset","offset",this,_offset),
   width("width","width",this,_width)
 { 
 } 


 RooErfPow2Pdf::RooErfPow2Pdf(const RooErfPow2Pdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   c0("c0",this,other.c0),
   c1("c1",this,other.c1),
   offset("offset",this,other.offset),
   width("width",this,other.width)
 { 
 } 



 Double_t RooErfPow2Pdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   Double_t width_tmp=width; if(width<1e-2){ width_tmp=1e-2;}
   return ErfPow2(x,c0,c1,offset,width_tmp);
 } 


 /////////////////////////////////////////////////////////

 ClassImp(RooAlpha4ErfPow2Pdf) 

 RooAlpha4ErfPow2Pdf::RooAlpha4ErfPow2Pdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _c0,
                        RooAbsReal& _c1,
                        RooAbsReal& _offset,
                        RooAbsReal& _width,
                        RooAbsReal& _c0a,
                        RooAbsReal& _c1a,
                        RooAbsReal& _offseta,
                        RooAbsReal& _widtha) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   c0("c0","c0",this,_c0),
   c1("c1","c1",this,_c1),
   offset("offset","offset",this,_offset),
   width("width","width",this,_width),
   c0a("c0a","c0a",this,_c0a),
   c1a("c1a","c1a",this,_c1a),
   offseta("offseta","offseta",this,_offseta),
   widtha("widtha","widtha",this,_widtha)
 { 
 } 


 RooAlpha4ErfPow2Pdf::RooAlpha4ErfPow2Pdf(const RooAlpha4ErfPow2Pdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   c0("c0",this,other.c0),
   c1("c1",this,other.c1),
   offset("offset",this,other.offset),
   width("width",this,other.width),
   c0a("c0a",this,other.c0a),
   c1a("c1a",this,other.c1a),
   offseta("offseta",this,other.offseta),
   widtha("widtha",this,other.widtha)
 { 
 } 



 Double_t RooAlpha4ErfPow2Pdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
    Double_t width_tmp=width; if(width<1e-2){ width_tmp=1e-2;}
    Double_t widtha_tmp=widtha; if(widtha<1e-2){ widtha_tmp=1e-2;}
   return ErfPow2(x,c0,c1,offset,width_tmp)/ErfPow2(x,c0a,c1a,offseta,widtha_tmp);
 } 


//////////////////////////////////RooErfPowExpPdf.cxx
ClassImp(RooErfPowExpPdf) 

Double_t  ErfPowExp(Double_t x,Double_t c0,Double_t c1, Double_t offset, Double_t width){
        if(width<1e-2)width=1e-2;
   Double_t sqrt_s=2000.;
   return TMath::Power(x/sqrt_s ,-1*(c1*TMath::Log(x/sqrt_s)) )*TMath::Exp(-1*x/sqrt_s*c0)*(1+ TMath::Erf((x-offset)/width)) /2. ; 
 }

 RooErfPowExpPdf::RooErfPowExpPdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _c0,
                        RooAbsReal& _c1,
                        RooAbsReal& _offset,
                        RooAbsReal& _width) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   c0("c0","c0",this,_c0),
   c1("c1","c1",this,_c1),
   offset("offset","offset",this,_offset),
   width("width","width",this,_width)
 { 
 } 


 RooErfPowExpPdf::RooErfPowExpPdf(const RooErfPowExpPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   c0("c0",this,other.c0),
   c1("c1",this,other.c1),
   offset("offset",this,other.offset),
   width("width",this,other.width)
 { 
 } 



 Double_t RooErfPowExpPdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   Double_t width_tmp=width; if(width<1e-2){ width_tmp=1e-2;}
   return ErfPowExp(x,c0,c1,offset,width_tmp);
 } 


 /////////////////////////////////////////////////////////

 ClassImp(RooAlpha4ErfPowExpPdf) 

 RooAlpha4ErfPowExpPdf::RooAlpha4ErfPowExpPdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _c0,
                        RooAbsReal& _c1,
                        RooAbsReal& _offset,
                        RooAbsReal& _width,
                        RooAbsReal& _c0a,
                        RooAbsReal& _c1a,
                        RooAbsReal& _offseta,
                        RooAbsReal& _widtha) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   c0("c0","c0",this,_c0),
   c1("c1","c1",this,_c1),
   offset("offset","offset",this,_offset),
   width("width","width",this,_width),
   c0a("c0a","c0a",this,_c0a),
   c1a("c1a","c1a",this,_c1a),
   offseta("offseta","offseta",this,_offseta),
   widtha("widtha","widtha",this,_widtha)
 { 
 } 


 RooAlpha4ErfPowExpPdf::RooAlpha4ErfPowExpPdf(const RooAlpha4ErfPowExpPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   c0("c0",this,other.c0),
   c1("c1",this,other.c1),
   offset("offset",this,other.offset),
   width("width",this,other.width),
   c0a("c0a",this,other.c0a),
   c1a("c1a",this,other.c1a),
   offseta("offseta",this,other.offseta),
   widtha("widtha",this,other.widtha)
 { 
 } 



 Double_t RooAlpha4ErfPowExpPdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
    Double_t width_tmp=width; if(width<1e-2){ width_tmp=1e-2;}
    Double_t widtha_tmp=widtha; if(widtha<1e-2){ widtha_tmp=1e-2;}
   return ErfPowExp(x,c0,c1,offset,width_tmp)/ErfPowExp(x,c0a,c1a,offseta,widtha_tmp);
 } 

//////////////////////////////////////////RooErfPowPdf.cxx
ClassImp(RooErfPowPdf) 

Double_t  ErfPow(Double_t x,Double_t c, Double_t offset, Double_t width){
   if(width<1e-2)width=1e-2;
   Double_t sqrt_s=2000.;
   return TMath::Power(x/sqrt_s ,c)*(1+ TMath::Erf((x-offset)/width)) /2. ; 
 }

 RooErfPowPdf::RooErfPowPdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _c,
                        RooAbsReal& _offset,
                        RooAbsReal& _width) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   c("c","c",this,_c),
   offset("offset","offset",this,_offset),
   width("width","width",this,_width)
 { 
 } 


 RooErfPowPdf::RooErfPowPdf(const RooErfPowPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   c("c",this,other.c),
   offset("offset",this,other.offset),
   width("width",this,other.width)
 { 
 } 



 Double_t RooErfPowPdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   Double_t width_tmp=width; if(width<1e-2){ width_tmp=1e-2;}
   return ErfPow(x,c,offset,width_tmp);
 } 


 /////////////////////////////////////////////////////////

 ClassImp(RooAlpha4ErfPowPdf) 

 RooAlpha4ErfPowPdf::RooAlpha4ErfPowPdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _c,
                        RooAbsReal& _offset,
                        RooAbsReal& _width,
                        RooAbsReal& _ca,
                        RooAbsReal& _offseta,
                        RooAbsReal& _widtha) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   c("c","c",this,_c),
   offset("offset","offset",this,_offset),
   width("width","width",this,_width),
   ca("ca","ca",this,_ca),
   offseta("offseta","offseta",this,_offseta),
   widtha("widtha","widtha",this,_widtha)
 { 
 } 


 RooAlpha4ErfPowPdf::RooAlpha4ErfPowPdf(const RooAlpha4ErfPowPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   c("c",this,other.c),
   offset("offset",this,other.offset),
   width("width",this,other.width),
   ca("ca",this,other.ca),
   offseta("offseta",this,other.offseta),
   widtha("widtha",this,other.widtha)
 { 
 } 



 Double_t RooAlpha4ErfPowPdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   Double_t width_tmp=width; if(width<1e-2){ width_tmp=1e-2;}
   Double_t widtha_tmp=widtha; if(widtha<1e-2){ widtha_tmp=1e-2;}
   return ErfPow(x,c,offset,width_tmp)/ErfPow(x,ca,offseta,widtha_tmp);
 } 

//////////////////////////////////////////RooPow2Pdf.cxx
ClassImp(RooPow2Pdf) 

 RooPow2Pdf::RooPow2Pdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _p0,
                        RooAbsReal& _p1) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   p0("p0","p0",this,_p0),
   p1("p1","p1",this,_p1)
 { 
 } 


 RooPow2Pdf::RooPow2Pdf(const RooPow2Pdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   p0("p0",this,other.p0),
   p1("p1",this,other.p1)
 { 
 } 



 Double_t RooPow2Pdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   Double_t sqrt_s=2000.;
   return TMath::Power( x/sqrt_s,-1*( p0+p1*TMath::Log(x/sqrt_s) ) )  ; 
 } 

////////////////////////////RooPowPdf.cxx
ClassImp(RooPowPdf) 

 RooPowPdf::RooPowPdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _p0) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   p0("p0","p0",this,_p0)
 { 
 } 


 RooPowPdf::RooPowPdf(const RooPowPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   p0("p0",this,other.p0)
 { 
 } 



 Double_t RooPowPdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   Double_t sqrt_s=2000.;
   return TMath::Power( x/sqrt_s, p0 )  ; 
 } 

/////////////////////////////  RooQCDPdf.cxx
ClassImp(RooQCDPdf) 

 RooQCDPdf::RooQCDPdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _p0,
                        RooAbsReal& _p1,
                        RooAbsReal& _p2) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   p0("p0","p0",this,_p0),
   p1("p1","p1",this,_p1),
   p2("p2","p2",this,_p2)
 { 
 } 


 RooQCDPdf::RooQCDPdf(const RooQCDPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   p0("p0",this,other.p0),
   p1("p1",this,other.p1),
   p2("p2",this,other.p2)
 { 
 } 



 Double_t RooQCDPdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   //Double_t sqrt_s=8000.;
   //return TMath::Power(1-x/sqrt_s ,p0)/TMath::Power(x/sqrt_s, p1+p2*TMath::Log(x/sqrt_s))  ; 

   Double_t sqrt_s=2000.;
   return TMath::Power(1-x/sqrt_s ,p0)/TMath::Power(x/sqrt_s, p1+p2*TMath::Log(x/sqrt_s))  ; 
   //return TMath::Power(x/sqrt_s ,p0)* (1+ TMath::Power(x/sqrt_s, p1) )*TMath::Power(1-x/sqrt_s ,p2) ; 
 } 

//////////////////////////////////////////RooUser1Pdf.cxx
ClassImp(RooUser1Pdf) 

 RooUser1Pdf::RooUser1Pdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _p0,
                        RooAbsReal& _p1
                        ) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   p0("p0","p0",this,_p0),
   p1("p1","p1",this,_p1)
 { 
 } 


 RooUser1Pdf::RooUser1Pdf(const RooUser1Pdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   p0("p0",this,other.p0),
   p1("p1",this,other.p1)
 { 
 } 



 Double_t RooUser1Pdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   Double_t sqrt_s=500.;
   return TMath::Power(1-x/sqrt_s ,p0)/TMath::Power(x/sqrt_s, p1)  ; 
   //return TMath::Power(1-x/p2 ,p0)/TMath::Power(x/p2, p1)  ; 
 } 



///////////////////////////////////////////////RooExpNPdf.cxx
Double_t ExpN(Double_t x, Double_t c, Double_t n){
    return TMath::Exp( c*TMath::Power(x,n) ); 
}

ClassImp(RooExpNPdf) 

 RooExpNPdf::RooExpNPdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _c,
                        RooAbsReal& _n) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   c("c","c",this,_c),
   n("n","n",this,_n)
 { 
 } 


 RooExpNPdf::RooExpNPdf(const RooExpNPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   c("c",this,other.c),
   n("n",this,other.n)
 { 
 } 



 Double_t RooExpNPdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   return ExpN(x,c,n); 
 } 


ClassImp(RooAlpha4ExpNPdf) 

 RooAlpha4ExpNPdf::RooAlpha4ExpNPdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _c0,
                        RooAbsReal& _n0,
                        RooAbsReal& _c1,
                        RooAbsReal& _n1) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   c0("c0","c0",this,_c0),
   n0("n0","n0",this,_n0),
   c1("c1","c1",this,_c1),
   n1("n1","n1",this,_n1)
 { 
 } 


 RooAlpha4ExpNPdf::RooAlpha4ExpNPdf(const RooAlpha4ExpNPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   c0("c0",this,other.c0),
   n0("n0",this,other.n0),
   c1("c1",this,other.c1),
   n1("n1",this,other.n1)
 { 
 } 




 Double_t RooAlpha4ExpNPdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   return ExpN(x,c0,n0)/ExpN(x,c1,n1); 
 } 



///////////////////////////////////////////////RooExpTailPdf.cxx
Double_t ExpTail(Double_t x, Double_t s, Double_t a){
	Double_t offset=600;
	Double_t t=x-offset;
	if( a<1e-6){a=1e-6;}
    return TMath::Exp( -t/(s+a*t) ); 
}
 
ClassImp(RooExpTailPdf) 

 RooExpTailPdf::RooExpTailPdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _s,
                        RooAbsReal& _a) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   s("s","s",this,_s),
   a("a","a",this,_a)
 { 
 } 


 RooExpTailPdf::RooExpTailPdf(const RooExpTailPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   s("s",this,other.s),
   a("a",this,other.a)
 { 
 } 



 Double_t RooExpTailPdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   return ExpTail(x, s, a) ; 
 } 

ClassImp(RooAlpha4ExpTailPdf) 

 RooAlpha4ExpTailPdf::RooAlpha4ExpTailPdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _s0,
                        RooAbsReal& _a0,
                        RooAbsReal& _s1,
                        RooAbsReal& _a1) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   s0("s0","s0",this,_s0),
   a0("a0","a0",this,_a0),
   s1("s1","s1",this,_s1),
   a1("a1","a1",this,_a1)
 { 
 } 


 RooAlpha4ExpTailPdf::RooAlpha4ExpTailPdf(const RooAlpha4ExpTailPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   s0("s0",this,other.s0),
   a0("a0",this,other.a0),
   s1("s1",this,other.s1),
   a1("a1",this,other.a1)
 { 
 } 



 Double_t RooAlpha4ExpTailPdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   return ExpTail(x, s0, a0)/ExpTail(x, s1, a1) ; 
 } 

///////////////////////////////////////////////Roo2ExpPdf.cxx
Double_t TwoExp(Double_t x, Double_t c0, Double_t c1, Double_t frac){
	if(frac<0){frac=0.;}
	if(frac>1){frac=1.;}
	//return frac*TMath::Exp(x*c0)+(1-frac)*TMath::Exp(x*c1);
	return TMath::Exp(x*c0)+frac*TMath::Exp(x*c1);
}

ClassImp(Roo2ExpPdf) 

 Roo2ExpPdf::Roo2ExpPdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _c0,
                        RooAbsReal& _c1,
                        RooAbsReal& _frac) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   c0("c0","c0",this,_c0),
   c1("c1","c1",this,_c1),
   frac("frac","frac",this,_frac)
 { 
 } 


 Roo2ExpPdf::Roo2ExpPdf(const Roo2ExpPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   c0("c0",this,other.c0),
   c1("c1",this,other.c1),
   frac("frac",this,other.frac)
 { 
 } 



 Double_t Roo2ExpPdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   //return 1.0 ; 
   return TwoExp(x,c0,c1,frac);
 } 

ClassImp(RooAlpha42ExpPdf) 

 RooAlpha42ExpPdf::RooAlpha42ExpPdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _c00,
                        RooAbsReal& _c01,
                        RooAbsReal& _frac0,
                        RooAbsReal& _c10,
                        RooAbsReal& _c11,
                        RooAbsReal& _frac1) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   c00("c00","c00",this,_c00),
   c01("c01","c01",this,_c01),
   frac0("frac0","frac0",this,_frac0),
   c10("c10","c10",this,_c10),
   c11("c11","c11",this,_c11),
   frac1("frac1","frac1",this,_frac1)
 { 
 } 


 RooAlpha42ExpPdf::RooAlpha42ExpPdf(const RooAlpha42ExpPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   c00("c00",this,other.c00),
   c01("c01",this,other.c01),
   frac0("frac0",this,other.frac0),
   c10("c10",this,other.c10),
   c11("c11",this,other.c11),
   frac1("frac1",this,other.frac1)
 { 
 } 



 Double_t RooAlpha42ExpPdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   //return 1.0 ; 
   return TwoExp(x,c00,c01,frac0)/TwoExp(x,c10,c11,frac1);
 } 



// RooAnaExpNPdf.cxx
ClassImp(RooAnaExpNPdf) 

 RooAnaExpNPdf::RooAnaExpNPdf(const char *name, const char *title, 
                        RooAbsReal& _x,
                        RooAbsReal& _c,
                        RooAbsReal& _n) :
   RooAbsPdf(name,title), 
   x("x","x",this,_x),
   c("c","c",this,_c),
   n("n","n",this,_n)
 { 
 } 


 RooAnaExpNPdf::RooAnaExpNPdf(const RooAnaExpNPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   x("x",this,other.x),
   c("c",this,other.c),
   n("n",this,other.n)
 { 
 } 



 Double_t RooAnaExpNPdf::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   return ExpN(x,c,n) ; 
 } 



 Int_t RooAnaExpNPdf::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
 { 
   // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
   // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
   // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
   // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
   // EXPRESSION MULTIPLE TIMES

   if (matchArgs(allVars,analVars,x)){cout<<"return 1"<<endl; return 1; } 
   cout<<"return 0"<<endl;
   return 0 ; 
 } 

Double_t gamma_in_mathematica(Double_t a, Double_t z){
	return (1-TMath::Gamma(a,z))*TMath::Gamma(a);
}

Double_t integral_ExpN(Double_t x, Double_t c, Double_t n){
	//return -1*( x*TMath::Power(-1*c*TMath::Power(x,n) , -1/n ) * gamma_in_mathematica( 1/n, -1*c*TMath::Power(x, n) )   )/n   ;
	return -1*( TMath::Power(-1*c , -1/n ) * gamma_in_mathematica( 1/n, -1*c*TMath::Power(x, n) )   )/n   ;
}

 Double_t RooAnaExpNPdf::analyticalIntegral(Int_t code, const char* rangeName) const  
 { 
   // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
   // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
   // BOUNDARIES FOR EACH OBSERVABLE x

   // assert(code==1) ; 
   // return (x.max(rangeName)-x.min(rangeName)) ; 

	if (code==1) { 
		Double_t x_min=x.min(rangeName);
		Double_t x_max=x.max(rangeName);

        Double_t minTerm=integral_ExpN(x_min,c,n);
        Double_t maxTerm=integral_ExpN(x_max,c,n);
		cout<<"maxTerm-minTerm="<<maxTerm-minTerm<<endl;
		return (maxTerm-minTerm) ;
	} 
	return 0 ; 
 } 




/////////////////////////////////////////////Util.cxx

void draw_error_band(RooAbsData &rdata, RooAbsPdf &rpdf, RooRealVar &rrv_number_events , RooFitResult *rfres, RooPlot *mplot, Int_t kcolor=6,char* opt="F", Int_t number_point=100, const Int_t number_errorband=2000)
{
	TRandom3 rand(1234);

	RooArgSet* argset_obs=rpdf.getObservables(rdata);
	TIterator *par=argset_obs->createIterator();
	par->Reset();
	RooRealVar *rrv_x=(RooRealVar*)par->Next();
	rrv_x->Print();
    rpdf.Print("v");
    rpdf.getParameters(RooArgSet(*rrv_x))->Print("v");
	rrv_number_events.Print();
	Double_t x_min=rrv_x->getMin();
	Double_t x_max=rrv_x->getMax();
	Double_t delta_x=(x_max-x_min)/number_point;
	//Double_t width_x=rrv_x->getBinWidth(1);
	Double_t width_x=mplot->getFitRangeBinW();
	//rdata.plotOn(mplot);
	//rpdf.plotOn(mplot,RooFit::VisualizeError(*rfres,1),RooFit::FillColor(kOrange));
	//rpdf.plotOn(mplot);

	Double_t number_events_mean = rrv_number_events.getVal();
	Double_t number_events_sigma= rrv_number_events.getError();

	TGraph *bkgpred=new TGraph(number_point+1);
	for(int i =0 ; i<= number_point ; i++){
		rrv_x->setVal(x_min+delta_x*i); 
		bkgpred->SetPoint( i , x_min+delta_x*i , rrv_number_events.getVal()*rpdf.getVal(*rrv_x)*width_x );
	}
	bkgpred->SetLineWidth(2);
	bkgpred->SetLineColor(kcolor);

	RooArgSet* par_pdf  = rpdf.getParameters(RooArgSet(*rrv_x)) ;
	//par_pdf->Print("v");

	TGraph* syst[number_errorband];
	for(int j=0;j<number_errorband;j++){
		syst[j]=new TGraph(number_point+1);
		RooArgList par_tmp = rfres->randomizePars();
		*par_pdf = par_tmp;
		Double_t number_events_tmp = rand.Gaus(number_events_mean,number_events_sigma);
		for(int i =0 ; i<=number_point ; i++){
			rrv_x->setVal(x_min+delta_x*i); 
			syst[j]->SetPoint( i , x_min+delta_x*i , number_events_tmp*rpdf.getVal(*rrv_x)*width_x);
		}
	}

	RooArgList par_tmp = rfres->floatParsFinal();
	*par_pdf = par_tmp;

	std::vector<double> val;
	val.resize(number_errorband);
	TGraph *ap=new TGraph(number_point+1);
	TGraph *am=new TGraph(number_point+1);
	TGraphAsymmErrors* errorband=new TGraphAsymmErrors(number_point+1);
	for(int i =0 ; i<= number_point ; i++){
		for(int j=0;j<number_errorband;j++){
			val[j]=(syst[j])->GetY()[i];
		}
		std::sort(val.begin(),val.end());
		ap->SetPoint(i, x_min+delta_x*i,val[Int_t(0.16*number_errorband)]);
		am->SetPoint(i, x_min+delta_x*i,val[Int_t(0.84*number_errorband)]);
		errorband->SetPoint(i, x_min+delta_x*i,bkgpred->GetY()[i] );
		errorband->SetPointError(i, 0.,0., bkgpred->GetY()[i]-val[Int_t(0.84*number_errorband)],val[Int_t(0.16*number_errorband)]-bkgpred->GetY()[i]);
	}
	ap->SetLineWidth(2);
	ap->SetLineColor(kcolor);
	am->SetLineWidth(2);
	am->SetLineColor(kcolor);
	//errorband->SetFillColor(kcolor);
	errorband->SetFillColor(kBlack);
    errorband->SetFillStyle(3013);

	if( TString(opt).Contains("F") ){ mplot->addObject(errorband,"E3"); //mplot->addObject(bkgpred);
            }
	if( TString(opt).Contains("L") ){ mplot->addObject(am); mplot->addObject(ap); }
	//mplot->addObject(errorband,"E3"); 
	//mplot->addObject(am); 
	//mplot->addObject(ap); 
}
void draw_error_band( RooAbsPdf &rpdf, char* xaxis_name, RooRealVar &rrv_number_events , RooArgList &paras, RooWorkspace &ws, RooPlot *mplot, Int_t kcolor=6,char* opt="F", Int_t number_point=100, const Int_t number_errorband=2000)
{
	TRandom3 rand(1234);

	RooRealVar *rrv_x=ws.var(xaxis_name);
    rpdf.Print("v");
    rpdf.getParameters(RooArgSet(*rrv_x))->Print("v");
	rrv_number_events.Print();
	Double_t x_min=rrv_x->getMin();
	Double_t x_max=rrv_x->getMax();
	Double_t delta_x=(x_max-x_min)/number_point;
	//Double_t width_x=rrv_x->getBinWidth(1);
	Double_t width_x=mplot->getFitRangeBinW();

	Double_t number_events_mean = rrv_number_events.getVal();
	Double_t number_events_sigma= rrv_number_events.getError();

	TGraph *bkgpred=new TGraph(number_point+1);
	for(int i =0 ; i<= number_point ; i++){
		rrv_x->setVal(x_min+delta_x*i); 
		bkgpred->SetPoint( i , x_min+delta_x*i , rrv_number_events.getVal()*rpdf.getVal(*rrv_x)*width_x );
	}
	bkgpred->SetLineWidth(2);
	bkgpred->SetLineColor(kcolor);

	TGraph* syst[number_errorband];
	for(int j=0;j<number_errorband;j++){
		for(Int_t ipara=0;ipara<paras.getSize();ipara++){
            ws.var(paras[ipara].GetName())->setConstant(0);
	        ws.var(paras[ipara].GetName())->setVal( rand.Gaus(0.,ws.var(paras[ipara].GetName())->getError()) );
            //ws.var(paras[ipara].GetName())->Print();
		}
    //{double tmpb;cout<<"tmpb";cin>>tmpb;}

		Double_t number_events_tmp = rand.Gaus(number_events_mean,number_events_sigma);
		syst[j]=new TGraph(number_point+1);
		for(int i =0 ; i<=number_point ; i++){
			rrv_x->setVal(x_min+delta_x*i); 
			syst[j]->SetPoint( i , x_min+delta_x*i , number_events_tmp*rpdf.getVal(*rrv_x)*width_x);
		}
	}

	std::vector<double> val;
	val.resize(number_errorband);
	TGraph *ap=new TGraph(number_point+1);
	TGraph *am=new TGraph(number_point+1);
	TGraphAsymmErrors* errorband=new TGraphAsymmErrors(number_point+1);
	for(int i =0 ; i<= number_point ; i++){
		for(int j=0;j<number_errorband;j++){
			val[j]=(syst[j])->GetY()[i];
		}
		std::sort(val.begin(),val.end());
		ap->SetPoint(i, x_min+delta_x*i,val[Int_t(0.16*number_errorband)]);
		am->SetPoint(i, x_min+delta_x*i,val[Int_t(0.84*number_errorband)]);
		errorband->SetPoint(i, x_min+delta_x*i,bkgpred->GetY()[i] );
		errorband->SetPointError(i, 0.,0., bkgpred->GetY()[i]-val[Int_t(0.84*number_errorband)],val[Int_t(0.16*number_errorband)]-bkgpred->GetY()[i]);
	}
	ap->SetLineWidth(2);
	ap->SetLineColor(kcolor);
	am->SetLineWidth(2);
	am->SetLineColor(kcolor);
	//errorband->SetFillColor(kcolor);
	errorband->SetFillColor(kBlack);
    errorband->SetFillStyle(3013);

	if( TString(opt).Contains("F") ){
            mplot->addObject(errorband,"E3");
            //mplot->addObject(bkgpred);
            }
	if( TString(opt).Contains("L") ){ mplot->addObject(am); mplot->addObject(ap); }
}


void draw_error_band_extendPdf(RooAbsData &rdata, RooExtendPdf &rpdf, RooFitResult *rfres, RooPlot *mplot, Int_t kcolor=6,char* opt="F", Int_t number_point=100, const Int_t number_errorband=2000)
{
	TRandom3 rand(1234);

	RooArgSet* argset_obs=rpdf.getObservables(rdata);
	TIterator *par=argset_obs->createIterator();
	par->Reset();
	RooRealVar *rrv_x=(RooRealVar*)par->Next();
	rrv_x->Print();
	Double_t x_min=rrv_x->getMin();
	Double_t x_max=rrv_x->getMax();
	Double_t delta_x=(x_max-x_min)/number_point;
	//Double_t width_x=rrv_x->getBinWidth(1);
	Double_t width_x=mplot->getFitRangeBinW();

	TGraph *bkgpred=new TGraph(number_point+1);
	for(int i =0 ; i<= number_point ; i++){
		rrv_x->setVal(x_min+delta_x*i); 
		bkgpred->SetPoint( i , x_min+delta_x*i , rpdf.expectedEvents(*rrv_x)*rpdf.getVal(*rrv_x)*width_x );
	}
	bkgpred->SetLineWidth(2);
	bkgpred->SetLineColor(kcolor);

	RooArgSet* par_pdf  = rpdf.getParameters(RooArgSet(*rrv_x)) ;
	par_pdf->Print("v");

	TGraph* syst[number_errorband];
	for(int j=0;j<number_errorband;j++){
		syst[j]=new TGraph(number_point+1);
		RooArgList par_tmp = rfres->randomizePars();
		*par_pdf = par_tmp;
		for(int i =0 ; i<=number_point ; i++){
			rrv_x->setVal(x_min+delta_x*i); 
			syst[j]->SetPoint( i , x_min+delta_x*i , rpdf.expectedEvents(*rrv_x)*rpdf.getVal(*rrv_x)*width_x);
		}
	}

	RooArgList par_tmp = rfres->floatParsFinal();
	*par_pdf = par_tmp;

	std::vector<double> val;
	val.resize(number_errorband);
	TGraph *ap=new TGraph(number_point+1);
	TGraph *am=new TGraph(number_point+1);
	TGraphAsymmErrors* errorband=new TGraphAsymmErrors(number_point+1);
	for(int i =0 ; i<= number_point ; i++){
		for(int j=0;j<number_errorband;j++){
			val[j]=(syst[j])->GetY()[i];
		}
		std::sort(val.begin(),val.end());
		ap->SetPoint(i, x_min+delta_x*i,val[Int_t(0.16*number_errorband)]);
		am->SetPoint(i, x_min+delta_x*i,val[Int_t(0.84*number_errorband)]);
		errorband->SetPoint(i, x_min+delta_x*i,bkgpred->GetY()[i] );
		errorband->SetPointError(i, 0.,0., bkgpred->GetY()[i]-val[Int_t(0.84*number_errorband)],val[Int_t(0.16*number_errorband)]-bkgpred->GetY()[i]);
	}
	ap->SetLineWidth(2);
	ap->SetLineColor(kcolor);
	am->SetLineWidth(2);
	am->SetLineColor(kcolor);
	//errorband->SetFillColor(kcolor);
	errorband->SetFillColor(kBlack);
    errorband->SetFillStyle(3013);

	if( TString(opt).Contains("F") ){ mplot->addObject(errorband,"E3"); }
	if( TString(opt).Contains("L") ){ mplot->addObject(am); mplot->addObject(ap); }
	//mplot->addObject(errorband,"E3"); 
	//mplot->addObject(am); 
	//mplot->addObject(ap); 
}

void draw_error_band2(RooAbsData &rdata, RooAbsPdf &rpdf, RooRealVar &rrv_number_events , RooFitResult *rfres, RooPlot *mplot, Int_t kcolor=9,char* opt="F", Int_t number_point=100, const Int_t number_errorband=2000)//don't think of covariance-matrix
{
	TRandom3 rand(1234);

	RooArgSet* argset_obs=rpdf.getObservables(rdata);
	TIterator *par=argset_obs->createIterator();
	par->Reset();
	RooRealVar *rrv_x=(RooRealVar*)par->Next();
	rrv_x->Print();
	rrv_number_events.Print();
	Double_t x_min=rrv_x->getMin();
	Double_t x_max=rrv_x->getMax();
	Double_t delta_x=(x_max-x_min)/number_point;
	//Double_t width_x=rrv_x->getBinWidth(1);
	Double_t width_x=mplot->getFitRangeBinW();

	Double_t number_events_mean = rrv_number_events.getVal();
	Double_t number_events_sigma= rrv_number_events.getError();

	TGraph *bkgpred=new TGraph(number_point+1);
	for(int i =0 ; i<= number_point ; i++){
		rrv_x->setVal(x_min+delta_x*i); 
		//cout<<rpdf.getVal(*rrv_x)<<endl;
		bkgpred->SetPoint( i , x_min+delta_x*i , rrv_number_events.getVal()*rpdf.getVal(*rrv_x)*width_x );
	}
	bkgpred->SetLineWidth(2);
	bkgpred->SetLineColor(kcolor);

	RooArgSet* par_pdf  = rpdf.getParameters(RooArgSet(*rrv_x)) ;
	par_pdf->Print("v");

	TGraph* syst[number_errorband];
	RooArgList par_ParsFinal = rfres->floatParsFinal();
	for(int j=0;j<number_errorband;j++){
		syst[j]=new TGraph(number_point+1);
		//RooArgList par_tmp = rfres->randomizePars();
		//*par_pdf = par_tmp;
        TIterator *par=par_pdf->createIterator();
        TIterator *par_final=par_ParsFinal.createIterator();
        par->Reset();
        par_final->Reset();
        RooRealVar* param=(RooRealVar*)par->Next();
        RooRealVar* param_final=(RooRealVar*)par_final->Next();
        while(param){
            param->setVal(rand.Gaus(param_final->getVal(),param_final->getError() ) );
            param=(RooRealVar*)par->Next();
            param_final=(RooRealVar*)par_final->Next();
             
        }
		Double_t number_events_tmp = rand.Gaus(number_events_mean,number_events_sigma);
		for(int i =0 ; i<=number_point ; i++){
			rrv_x->setVal(x_min+delta_x*i); 
			syst[j]->SetPoint( i , x_min+delta_x*i , number_events_tmp*rpdf.getVal(*rrv_x)*width_x);
		}
	}

	*par_pdf = par_ParsFinal;

	std::vector<double> val;
	val.resize(number_errorband);
	TGraph *ap=new TGraph(number_point+1);
	TGraph *am=new TGraph(number_point+1);
	TGraphAsymmErrors* errorband=new TGraphAsymmErrors(number_point+1);
	for(int i =0 ; i<= number_point ; i++){
		for(int j=0;j<number_errorband;j++){
			val[j]=(syst[j])->GetY()[i];
		}
		std::sort(val.begin(),val.end());
		ap->SetPoint(i, x_min+delta_x*i,val[Int_t(0.16*number_errorband)]);
		am->SetPoint(i, x_min+delta_x*i,val[Int_t(0.84*number_errorband)]);
		errorband->SetPoint(i, x_min+delta_x*i,bkgpred->GetY()[i] );
		errorband->SetPointError(i, 0.,0., bkgpred->GetY()[i]-val[Int_t(0.84*number_errorband)],val[Int_t(0.16*number_errorband)]-bkgpred->GetY()[i]);
	}
	ap->SetLineWidth(2);
	ap->SetLineColor(kcolor);
	am->SetLineWidth(2);
	am->SetLineColor(kcolor);
	//errorband->SetFillColor(kcolor);
	errorband->SetFillColor(kBlack);
    errorband->SetFillStyle(3013);
    errorband->SetName("Uncertainty");

	if( TString(opt).Contains("F") ){ mplot->addObject(errorband,"E3"); }
	if( TString(opt).Contains("L") ){ mplot->addObject(am); mplot->addObject(ap); }
	//mplot->addObject(errorband,"E3"); 
	//mplot->addObject(am); 
	//mplot->addObject(ap); 
}
void draw_error_band_Decor( char* pdf_name, char* xaxis_name, RooArgList &paras, RooWorkspace &ws,RooRealVar &rrv_shape_scale , RooPlot *mplot, Int_t kcolor=6,char* opt="F", Int_t number_point=100, const Int_t number_errorband=2000)
{
	TRandom3 rand(1234);

	RooRealVar *rrv_x=ws.var(xaxis_name);
	rrv_x->Print();
	Double_t x_min=rrv_x->getMin();
	Double_t x_max=rrv_x->getMax();
	Double_t delta_x=(x_max-x_min)/number_point;
	//Double_t width_x=rrv_x->getBinWidth(1);
	Double_t width_x=mplot->getFitRangeBinW();

	Double_t shape_scale = rrv_shape_scale.getVal();
	Double_t shape_scale_error = rrv_shape_scale.getError();

	TGraph *bkgpred=new TGraph(number_point+1);
	for(int i =0 ; i<= number_point ; i++){
		rrv_x->setVal(x_min+delta_x*i); 
		bkgpred->SetPoint( i , x_min+delta_x*i , shape_scale*ws.pdf(pdf_name)->getVal() );
	}
	bkgpred->SetLineWidth(2);
	bkgpred->SetLineColor(kcolor+3);

	TGraph* syst[number_errorband];
	for(int j=0;j<number_errorband;j++){
		for(Int_t ipara=0;ipara<paras.getSize();ipara++){
	        ws.var(paras[ipara].GetName())->setVal( rand.Gaus(0.,1.) );
		}

        Double_t shape_scale_tmp=rand.Gaus(shape_scale,shape_scale_error);
		syst[j]=new TGraph(number_point+1);
		for(int i =0 ; i<=number_point ; i++){
			rrv_x->setVal(x_min+delta_x*i); 
			syst[j]->SetPoint( i , x_min+delta_x*i ,shape_scale_tmp*ws.pdf(pdf_name)->getVal());
		}
	}

	std::vector<double> val;
	val.resize(number_errorband);
	TGraph *ap=new TGraph(number_point+1);
	TGraph *am=new TGraph(number_point+1);
	TGraphAsymmErrors* errorband=new TGraphAsymmErrors(number_point+1);
	for(int i =0 ; i<= number_point ; i++){
		for(int j=0;j<number_errorband;j++){
			val[j]=(syst[j])->GetY()[i];
		}
		std::sort(val.begin(),val.end());
		ap->SetPoint(i, x_min+delta_x*i,val[Int_t(0.16*number_errorband)]);
		am->SetPoint(i, x_min+delta_x*i,val[Int_t(0.84*number_errorband)]);
		errorband->SetPoint(i, x_min+delta_x*i,bkgpred->GetY()[i] );
		errorband->SetPointError(i, 0.,0., bkgpred->GetY()[i]-val[Int_t(0.84*number_errorband)],val[Int_t(0.16*number_errorband)]-bkgpred->GetY()[i]);
	}
	ap->SetLineWidth(2);
	ap->SetLineColor(kcolor);
	am->SetLineWidth(2);
	am->SetLineColor(kcolor);
	//errorband->SetFillColor(kcolor);
	errorband->SetFillColor(kBlack);
    errorband->SetFillStyle(3013);
    errorband->SetName("Uncertainty");

	//mplot->addObject(errorband,"E3"); 
	//mplot->addObject(bkgpred); 
	//mplot->addObject(am); 
	//mplot->addObject(ap); 

    if( TString(opt).Contains("F") ){
            mplot->addObject(errorband,"E3"); 
            mplot->addObject(bkgpred);
            }
	if( TString(opt).Contains("L") ){
            mplot->addObject(am); mplot->addObject(ap); 
            mplot->addObject(bkgpred);
            }

	for(Int_t ipara=0;ipara<paras.getSize();ipara++){
		ws.var(paras[ipara].GetName())->setVal(0.);
	}

} 


void draw_error_band_shape_Decor( char* pdf_name, char* xaxis_name, RooArgList &paras, RooWorkspace &ws,Double_t sigma , RooPlot *mplot, Int_t kcolor=6,char* opt="F", Int_t fillstyle=3013,char* uncertainty_title="", Int_t number_point=100, const Int_t number_errorband=2000)
{
	TRandom3 rand(1234);

	RooRealVar *rrv_x=ws.var(xaxis_name);
	rrv_x->Print();
	Double_t x_min=rrv_x->getMin();
	Double_t x_max=rrv_x->getMax();
	Double_t delta_x=(x_max-x_min)/number_point;
	//Double_t width_x=rrv_x->getBinWidth(1);
	Double_t width_x=mplot->getFitRangeBinW();

	TGraph *bkgpred=new TGraph(number_point+1);
    //{double tmpb;cout<<"tmpb";cin>>tmpb;}
	for(int i =0 ; i<= number_point ; i++){
		rrv_x->setVal(x_min+delta_x*i); 
		bkgpred->SetPoint( i , x_min+delta_x*i , ws.pdf(pdf_name)->getVal(*rrv_x)*width_x );
	}
    //{double tmpb;cout<<"tmpb";cin>>tmpb;}
	bkgpred->SetLineWidth(2);
	bkgpred->SetLineColor(kcolor+3);

	TGraph* syst[number_errorband];
	for(int j=0;j<number_errorband;j++){
        //cout<<"random "<<j<<"---------------------------------------------------"<<endl;
		for(Int_t ipara=0;ipara<paras.getSize();ipara++){
	        ws.var(paras[ipara].GetName())->setVal( rand.Gaus(0.,sigma) );
            //cout<<paras[ipara].GetName()<<endl;
	        //ws.var(paras[ipara].GetName())->Print("");
		}

		syst[j]=new TGraph(number_point+1);
		for(int i =0 ; i<=number_point ; i++){
			rrv_x->setVal(x_min+delta_x*i); 
			syst[j]->SetPoint( i , x_min+delta_x*i ,ws.pdf(pdf_name)->getVal(*rrv_x)*width_x);
		}
	}
	std::vector<double> val;
	val.resize(number_errorband);
	TGraph *ap=new TGraph(number_point+1);
	TGraph *am=new TGraph(number_point+1);
	TGraphAsymmErrors* errorband=new TGraphAsymmErrors(number_point+1);
	for(int i =0 ; i<= number_point ; i++){
		for(int j=0;j<number_errorband;j++){
			val[j]=(syst[j])->GetY()[i];
		}
		std::sort(val.begin(),val.end());
		ap->SetPoint(i, x_min+delta_x*i,val[Int_t(0.16*number_errorband)]);
		am->SetPoint(i, x_min+delta_x*i,val[Int_t(0.84*number_errorband)]);
		errorband->SetPoint(i, x_min+delta_x*i,bkgpred->GetY()[i] );
		errorband->SetPointError(i, 0.,0., bkgpred->GetY()[i]-val[Int_t(0.84*number_errorband)],val[Int_t(0.16*number_errorband)]-bkgpred->GetY()[i]);
        if (i==55)cout<<val[Int_t(0.16*number_errorband)]<<"  "<<bkgpred->GetY()[i] <<"  "<<val[Int_t(0.84*number_errorband)] <<endl;
	}
	ap->SetLineWidth(2);
	ap->SetLineColor(kcolor);
	am->SetLineWidth(2);
	am->SetLineColor(kcolor);
	//errorband->SetFillColor(kBlack+7*(sigma-1));
	errorband->SetFillColor(kcolor);
    //errorband->SetFillStyle(3013+sigma-1);
    errorband->SetFillStyle(fillstyle);
    //errorband->SetName(Form("Uncertainty of %g#sigma",sigma));
    errorband->SetName(Form("%s %g#sigma",uncertainty_title,sigma));

    if( TString(opt).Contains("F") ){ mplot->addObject(errorband,"E3"); }
	if( TString(opt).Contains("L") ){ mplot->addObject(am); mplot->addObject(ap); }
	for(Int_t ipara=0;ipara<paras.getSize();ipara++){
		ws.var(paras[ipara].GetName())->setVal(0.);
	}
} 



double Calc_error_extendPdf(RooAbsData &rdata, RooExtendPdf &rpdf, RooFitResult *rfres, char* range, const Int_t calc_times=2000)
{
	TRandom3 rand(1234);

	RooArgSet* argset_obs=rpdf.getObservables(rdata);
	TIterator *par=argset_obs->createIterator();
	par->Reset();
	RooRealVar *rrv_x=(RooRealVar*)par->Next();
	rrv_x->Print();
	Double_t x_min=rrv_x->getMin();
	Double_t x_max=rrv_x->getMax();

    RooAbsReal* fullInt = rpdf.createIntegral(*rrv_x,*rrv_x);
    RooAbsReal* signalInt = rpdf.createIntegral(*rrv_x,*rrv_x,range);
    double fullInt_var=fullInt->getVal();
    double signalInt_var=signalInt->getVal()/fullInt_var;

    double signal_number_media=signalInt_var*rpdf.expectedEvents(*rrv_x);
    cout<<"signal_number_media="<<signal_number_media<<endl;


	RooArgSet* par_pdf  = rpdf.getParameters(RooArgSet(*rrv_x)) ;
	par_pdf->Print("v");

	std::vector<double> val;
	val.resize(calc_times);
	for(int j=0;j<calc_times;j++){
		RooArgList par_tmp = rfres->randomizePars();
		*par_pdf = par_tmp;

        double fullInt_var=fullInt->getVal();
        double signalInt_var=signalInt->getVal()/fullInt_var;
        //cout<<"signalInt_var="<<signalInt_var<<endl;

        double signal_number_media=signalInt_var*rpdf.expectedEvents(*rrv_x);
        val[j]=signal_number_media;
	}

	std::sort(val.begin(),val.end());
    //cout<<"signal_number_low_error="<<signal_number_media-val[Int_t(0.16*calc_times)];
    //cout<<"signal_number_hig_error="<<val[Int_t(0.84*calc_times)]-signal_number_media;
    return (val[Int_t(0.84*calc_times)]-val[Int_t(0.16*calc_times)])/2.;
}

double Calc_error( char* rpdfname, char* xaxis_name , RooArgList &paras, RooWorkspace &ws,char*range, const Int_t calc_times=2000){
	TRandom3 rand(1234);

	RooRealVar *rrv_x=ws.var(xaxis_name); rrv_x->Print();
	Double_t x_min=rrv_x->getMin();
	Double_t x_max=rrv_x->getMax();
	RooAbsPdf*rpdf=ws.pdf(rpdfname);

    RooAbsReal* fullInt = rpdf->createIntegral(*rrv_x,*rrv_x);
    RooAbsReal* signalInt = rpdf->createIntegral(*rrv_x,*rrv_x,range);
    double fullInt_var=fullInt->getVal();
    double signalInt_var=signalInt->getVal()/fullInt_var;

    double signal_number_media=signalInt_var;
    //cout<<"signal_number_media="<<signal_number_media<<endl;


	std::vector<double> val;
	val.resize(calc_times);
	for(int j=0;j<calc_times;j++){
		for(Int_t ipara=0;ipara<paras.getSize();ipara++){
            ws.var(paras[ipara].GetName())->setConstant(0);
	        ws.var(paras[ipara].GetName())->setVal( rand.Gaus(0.,ws.var(paras[ipara].GetName())->getError()) );
		}

        double fullInt_var=fullInt->getVal();
        double signalInt_var=signalInt->getVal()/fullInt_var;

        double signal_number_media=signalInt_var;
        val[j]=signal_number_media;
        //cout<<"signal_number_tmp="<<signal_number_media<<endl;
	}
	for(Int_t ipara=0;ipara<paras.getSize();ipara++){ ws.var(paras[ipara].GetName())->setVal(0.); }

	std::sort(val.begin(),val.end());
	double number_error=(val[Int_t(0.84*calc_times)]-val[Int_t(0.16*calc_times)])/2./signal_number_media;
    return number_error;
}





